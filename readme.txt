solutions for tasks from hexlet nodejs developer course 
here explanation for each quizz and links to hexlet site

001-treeUnfolder.js
return unfolded tree as string
https://ru.hexlet.io/courses/js-trees/lessons/traversal/theory_unit
/*
                *A
               / | \
              B  C  D
             /|     |\
            E F     G J 
В примере выбрана схема дерева на массивах. Каждый элемент дерева массив с 2 элементами
Первый элемент массива это значение узла, второй (не обязателен)- дети.
 По пунктам:
1 извлекаем из дерева (или поддерева) значение и детей
2 Печатаем значение
3 Если нет детей выходим, если есть то для каждого вызываем рекурсивно функцию dfs.
Все что будет дальше делаться по ходу курса, неизменно базируется на этом алгоритме.
Попробуйте открыть редактор на своем компьютере и самостоятельно реализуйте эту функцию без 
подглядывания. 
Так вы убедитесь в том, что поняли происходящее.*/
#-----------------------------------------------------------------------------------------

002-treePrinter.js
hexlet variant of 001 task.
Just print tree.
#------------------------------------------------------------------------------------------

003-downcaseFileNames.js
Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход директорию,
приводит имена всех файлов в этой директории к нижнему регистру и возвращает ее наружу.
--> Пример директории в константе treeToChec
    элемент дерева такой {children:[], meta:{}, name:'', type:''}
                      *A(dir,/)
                      |         \
                    B(dir,etc)  G(file,host)
                   /       \
              C(dir,nginx) D(dir,consul)
                              |
                           E(file,config)
    особое внимание обратить на использование опреатора spread в решении (не мое с хекслета)
#------------------------------------------------------------------------------------------

004-treeMapper.js
hexlet variant https://ru.hexlet.io/courses/js-trees/lessons/map/theory_unit
Используем самописный map для отображения структуры. Функция, которая будет изменять
элементы (но не структуру) передается, в виде functionForMap.
Внимательно читать пояснения в коде. Интересное использование spread и деструктивного
присваивания.
#-----------------------------------------------------------------------------------------

005-treeMapper2.js
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход функцию-обработчик и дерево,
а возвращает отображенное дерево.
const actual = map(n => ({ ...n, name: n.name.toUpperCase() }), tree);
Аналогично 004, но callback для самописного мап, возвращает обработынный узел целиком,
а не только измененное поле.
#---------------------------------------------------------------------------------------

006-treeFilter.js
hexlet variant https://ru.hexlet.io/courses/js-trees/lessons/filter/theory_unit
      a *
      /|\
   B * C * d
    /|   |\
   e  F  G j
Пример задачи: Отвильтровать только строчные листы дерева.
Глядя на реализацию фильтра, видно что если нода не удовлетворяет предикату,
то ее дети не рассматриваются вообще. В примере выше это нода B.
Соответственно ее дети e и F даже не анализируются и отфильтровываются вместе с B.
Интересно выглядит и вот эта запись children.map(c => filter(f, c)).filter(v => v).
Дело в том что наш фильтр, не работает со списком, а работает с конкретным корневым узлом.
Соответственно если мы обрабатываем детей, то в результате фильтрации количество детей не уменьшается.
На их месте появляется null. Поэтому обход детей совершается используя map на массиве children с последующим filter.
Тогда все null элементы отфильтруются.


