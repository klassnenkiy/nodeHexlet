solutions for tasks from hexlet nodejs developer course 
here explanation for each quizz and links to hexlet site

001-treeUnfolder.js
return unfolded tree as string
https://ru.hexlet.io/courses/js-trees/lessons/traversal/theory_unit
/*
                *A
               / | \
              B  C  D
             /|     |\
            E F     G J 
В примере выбрана схема дерева на массивах. Каждый элемент дерева массив с 2 элементами
Первый элемент массива это значение узла, второй (не обязателен)- дети.
 По пунктам:
1 извлекаем из дерева (или поддерева) значение и детей
2 Печатаем значение
3 Если нет детей выходим, если есть то для каждого вызываем рекурсивно функцию dfs.
Все что будет дальше делаться по ходу курса, неизменно базируется на этом алгоритме.
Попробуйте открыть редактор на своем компьютере и самостоятельно реализуйте эту функцию без 
подглядывания. 
Так вы убедитесь в том, что поняли происходящее.*/
#-----------------------------------------------------------------------------------------

002-treePrinter.js
hexlet variant of 001 task.
Just print tree.
#------------------------------------------------------------------------------------------

003-downcaseFileNames.js
Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход директорию,
приводит имена всех файлов в этой директории к нижнему регистру и возвращает ее наружу.
--> Пример директории в константе treeToChec
    элемент дерева такой {children:[], meta:{}, name:'', type:''}
                      *A(dir,/)
                      |         \
                    B(dir,etc)  G(file,host)
                   /       \
              C(dir,nginx) D(dir,consul)
                              |
                           E(file,config)
особое внимание обратить на использование опреатора spread в решении (не мое с хекслета)
#------------------------------------------------------------------------------------------

004-treeMapper.js
hexlet variant https://ru.hexlet.io/courses/js-trees/lessons/map/theory_unit
Используем самописный map для отображения структуры. Функция, которая будет изменять
элементы (но не структуру) передается, в виде functionForMap.
Внимательно читать пояснения в коде. Интересное использование spread и деструктивного
присваивания.
#-----------------------------------------------------------------------------------------

005-treeMapper2.js
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход функцию-обработчик и дерево,
а возвращает отображенное дерево.
const actual = map(n => ({ ...n, name: n.name.toUpperCase() }), tree);
Аналогично 004, но callback для самописного мап, возвращает обработынный узел целиком,
а не только измененное поле.
#---------------------------------------------------------------------------------------

006-treeFilter.js
hexlet variant https://ru.hexlet.io/courses/js-trees/lessons/filter/theory_unit
      a *
      /|\
   B * C * d
    /|   |\
   e  F  G j
Пример задачи: Отфильтровать только строчные листы дерева.
Глядя на реализацию фильтра, видно что если нода не удовлетворяет предикату,
то ее дети не рассматриваются вообще. В примере выше это нода B.
Соответственно ее дети e и F даже не анализируются и отфильтровываются вместе с B.
Интересно выглядит и вот эта запись children.map(c => filter(f, c)).filter(v => v).
Дело в том что наш фильтр, не работает со списком, а работает с конкретным корневым узлом.
Соответственно если мы обрабатываем детей, то в результате фильтрации количество детей не уменьшается.
На их месте появляется null. Поэтому обход детей совершается используя map на массиве children с последующим filter.
Тогда все null элементы отфильтруются.
#-----------------------------------------------------------------------------------

007-treeFilter2.js
ПРАКТИКА
ЗАДАЧА - отфильтровать дерево по заданной функции (предикат)
https://ru.hexlet.io/courses/js-trees/lessons/filter/exercise_unit
filter.js
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход предикат и дерево,
а возвращает отфильтрованное дерево по предикату.
const actual = filter(n => n.type === 'directory', tree);

#-----------------------------------------------------------------------------------

008-treeSample
Образец дерева для дальнейшей обработки
#------------------------------------------------------------------------------------

009-treeReducer
ЗАДАЧА- посчитать кол-во узлов дерева.
Главная особенность reduce в наличии аккумулятора, который протаскивается сквозь
все вызовы до самой глубины, а затем поднимается наверх и, в конце концов, возвращается наружу.
Вызов reduce на каждом ребенке должен происходить с аккумулятором,
протаскиваемым сквозь обработку каждого ребенка. Из-за этого получается,
что снаружи есть reduce перебирающий children, в то время как каждый ребенок
принимает на вход текущий acc внешнего reduce и запускает внутренний с этим аккумулятором.
#------------------------------------------------------------------------------------

010-treeReducer2
ПРАКТИКА  https://ru.hexlet.io/courses/js-trees/lessons/reduce/exercise_unit
ЗАДАЧА - посчитать кол-во узлов дерева, которое состоит из обьектов (нод),
логика подсчета задается фунцией предикатом.
treeReducer((acc, n) => acc + 1, tree, 0); // => 6 - простой пример
treeReducer((acc, n) => (n.type === 'file' ? acc + 1 : acc), tree, 0); // считаем только файлы
treeReducer((acc, n) => (n.type === 'directory' ? acc + 1 : acc), tree, 0);
#-----------------------------------------------------------------------------------

011-findEmptyDirsDepth
https://ru.hexlet.io/courses/js-trees/lessons/search/theory_unit
ЗАДАЧА - найти в дереве пустые папки, поиск проводить только на заданную глубину.

Так как наша реализация reduce не предоставляет информацию о том на какой глубине текущая нода,
то можно выполнить обход вручную, передавая два аккумулятора, один с итоговым массивом,
второй с уровнем вложенности.
Несколько важных моментов:
-Теперь нужно отслеживать текущую глубину, поэтому она передается в iter,
с каждой глубиной увеличиваясь на единицу.
-Если зашли глубже чем надо, то возвращаем результат.
В остальном код такой же как и в обычном reduce.
#---------------------------------------------------------------------------------------

012-treeFactory
ПРОБЛЕМА - в практике к уроку деревья, все деревья для тестов создаются с помощью
скрытых функций mkdir, mkfile
ЗАДАЧА - написать эти функции
mkdir должна вернуть обьект c сигнатурой {children:[], meta:{}, name:'', type:'directory'}
mkfile - {meta:{}, name:'', type:'file', size: {}}
РЕШЕНИЕ - использовать классы, указанные функции просто вызывают конструкторы и возвращают
готовые объекты.
#---------------------------------------------------------------------------------------

013-findFilesByName.js
ПРАКТИКА
https://ru.hexlet.io/courses/js-trees/lessons/search/exercise_unit
ЗАДАЧА -
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход файловое дерево
и подстроку, а возвращает список файлов, имена которых содержат эту подстроку.
Обратите внимание на то что возвращается не просто имя файла, а полный путь до файла начиная от корня.
Для построения путей, используйте функцию path.join.
Файловое Дерево создается через вызов:
const tree = mkdir('/', [
  mkdir('etc', [
    mkdir('apache'),
    mkdir('nginx', [
      mkfile('nginx.conf', { size: 800 }),
    ]),
    mkdir('consul', [
      mkfile('config.json', { size: 1200 }),
      mkfile('data', { size: 8200 }),
      mkfile('raft', { size: 80 }),
    ]),
  ]),
  mkfile('hosts', { size: 3500 }),
  mkfile('resolve', { size: 1000 }),
]);

findFilesByName(tree, 'co');
// => ['/etc/nginx/nginx.conf', '/etc/consul/config.json']
#-----------------------------------------------------------------------------

013-h-findFilesByName.js
Решение предыдущей задачи от хекслет. Более правильное и элегантное. Требует несложной
дополнительной функции path. ВНИМАТЕЛЬНО ЧИТАЕМ ПОЯСНЕНИЯ К КОДУ, ЭТО ОЧЕНЬ ВАЖНАЯ ДЛЯ
ПОНИМАНИЯ РАБОТЫ С ДЕРЕВЬЯМИ ЗАДАЧА!
#---------------------------------------------------------------------------------

014-flattenNestedList.js
ПРАКТИКА https://ru.hexlet.io/challenges/js_trees_flatten
Реализуйте и экспортируйте по умолчанию функцию flatten, которая делает плоским вложенный массив.
const list = [1, 2, [3, 5], [[4, 3], 2]];
// [1, 2, 3, 5, 4, 3, 2]
